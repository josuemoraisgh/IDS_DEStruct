name: Build & Release (Windows MinGW, portable) - IDS_DEStruct

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Vers√£o/Tag (ex.: v1.0.0)"
        required: true
        type: string
      prerelease:
        description: "Marcar como pr√©-release?"
        required: false
        default: false
        type: boolean
      notes:
        description: "Notas da release (opcional)"
        required: false
        type: string

permissions:
  contents: write

env:
  VERSION: ${{ github.event.inputs.version }}
  QT_VERSION: "5.15.2"
  ZIP_NAME: IDS_DEStruct-${{ github.event.inputs.version }}-windows-x64.zip

jobs:
  build-windows-mingw:
    name: Windows (MinGW + Qt5 + Qwt local)
    runs-on: windows-latest

    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Instalar Qt5
        uses: jurplel/install-qt-action@v3
        with:
          version: ${{ env.QT_VERSION }}
          host: windows
          target: desktop
          arch: win64_mingw81
          tools: 'tools_mingw'
          cache: true

      - name: Garantir MinGW toolchain (aqt)
        shell: pwsh
        run: |
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) {
            throw "Qt5_Dir/Qt5_DIR n√£o definido pelo install-qt-action"
          }
          $qtBase = Split-Path -Parent (Split-Path -Parent $qtRoot)
          $mingwToolBin = Join-Path $qtBase "Tools\mingw810_64\bin"
          $gppPath = Join-Path $mingwToolBin "g++.exe"

          if (-not (Test-Path $gppPath)) {
            Write-Host "MinGW toolchain nao encontrado. Instalando via aqt..."
            Write-Host "Listando variantes disponiveis de tools_mingw..."
            $variants = python -m aqt list-tool windows desktop tools_mingw
            $variant = ($variants | Where-Object { $_ -match '^mingw' } | Select-Object -First 1)
            if (-not $variant) {
              Write-Host "Nao foi possivel detectar variante do tools_mingw."
              Write-Host $variants
              throw "tools_mingw sem variantes disponiveis"
            }
            Write-Host "Usando variante: $variant"
            python -m aqt install-tool windows desktop tools_mingw $variant --outputdir $qtBase
          }

          if (-not (Test-Path $gppPath)) {
            Write-Host "Falha ao encontrar g++.exe em $mingwToolBin"
            if (Test-Path (Join-Path $qtBase "Tools")) {
              Get-ChildItem -Path (Join-Path $qtBase "Tools") -Directory | Select-Object Name | Write-Host
            }
            throw "MinGW toolchain nao instalado"
          }
          Write-Host "‚úî MinGW toolchain OK: $mingwToolBin"

      - name: Configurar vari√°veis de ambiente do MinGW do Qt
        shell: pwsh
        run: |
          Write-Host "Configurando ambiente MinGW..."
          
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) {
            throw "Qt5_Dir/Qt5_DIR n√£o definido pelo install-qt-action"
          }
          $qtBase = Split-Path -Parent (Split-Path -Parent $qtRoot)
          $qtBin = Join-Path $qtRoot "bin"
          $toolsRoot = Join-Path $qtBase "Tools"

          $toolsMingwBin = Join-Path $toolsRoot "mingw810_64\bin"

          $gppPath = Join-Path $qtBin "g++.exe"
          $makePath = Join-Path $qtBin "mingw32-make.exe"

          if (-not (Test-Path $gppPath) -or -not (Test-Path $makePath)) {
            Write-Host "g++/mingw32-make n√£o encontrados em $qtBin. Procurando em $toolsRoot..."
            if (Test-Path $toolsMingwBin) {
              $gppPath = Join-Path $toolsMingwBin "g++.exe"
              $makePath = Join-Path $toolsMingwBin "mingw32-make.exe"
            } elseif (Test-Path $toolsRoot) {
              $gppFound = Get-ChildItem -Path $toolsRoot -Filter "g++.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              $makeFound = Get-ChildItem -Path $toolsRoot -Filter "mingw32-make.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($gppFound) { $gppPath = $gppFound.FullName }
              if ($makeFound) { $makePath = $makeFound.FullName }
            }
          }

          if (-not (Test-Path $gppPath)) {
            throw "g++ n√£o encontrado (Qt bin ou Tools)."
          }
          if (-not (Test-Path $makePath)) {
            throw "mingw32-make n√£o encontrado (Qt bin ou Tools)."
          }

          $mingwBin = Split-Path -Parent $gppPath
          Write-Host "‚úî MinGW encontrado: $mingwBin"

          # Adicionar ao PATH (PowerShell)
          $env:PATH = "$mingwBin;$env:PATH"

          # Adicionar ao GITHUB_PATH para passos subsequentes
          Add-Content -Path $env:GITHUB_PATH -Value $mingwBin

          # Exportar caminhos para outros passos
          "QT_GPP_PATH=$gppPath" | Out-File -FilePath $env:GITHUB_ENV -Append
          "QT_MINGW_MAKE=$makePath" | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "‚úî MinGW adicionado ao PATH"
          Write-Host "g++: $gppPath"
          Write-Host "mingw32-make: $makePath"

      - name: Validar vers√£o
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace($env:VERSION)) {
            throw "Vers√£o n√£o informada"
          }
          Write-Host "‚úî Vers√£o/Tag: $env:VERSION"

      - name: Verificar estrutura do projeto
        shell: pwsh
        run: |
          Write-Host "Verificando arquivos do projeto..."
          if (-not (Test-Path "IDS_DEStruct.pro")) {
            throw "IDS_DEStruct.pro n√£o encontrado"
          }
          if (-not (Test-Path "qwt")) {
            throw "Pasta qwt/ n√£o encontrada"
          }
          if (-not (Test-Path "qwt/lib")) {
            throw "Pasta qwt/lib/ n√£o encontrada"
          }
          if (-not (Test-Path "qwt/src")) {
            throw "Pasta qwt/src/ n√£o encontrada"
          }
          Write-Host "‚úî Estrutura do projeto OK"
          Write-Host "Conte√∫do de qwt/lib:"
          Get-ChildItem -Path "qwt/lib" | Select-Object Name

      - name: Testar compilador g++
        shell: pwsh
        run: |
          Write-Host "Testando compilador g++..."
          
          # Usar g++ encontrado na etapa anterior
          $qtGppPath = $env:QT_GPP_PATH
          if (-not $qtGppPath) {
            throw "QT_GPP_PATH n√£o definido"
          }
          
          if (Test-Path $qtGppPath) {
            Write-Host "‚úî Encontrado g++ do Qt: $qtGppPath"
            Write-Host "Vers√£o:"
            & $qtGppPath --version | Write-Host
          } else {
            Write-Host "‚ùå g++ do Qt n√£o encontrado em $qtGppPath"
          }
          
          # Tamb√©m verificar o que est√° no PATH
          $pathGpp = (Get-Command g++ -ErrorAction SilentlyContinue).Source
          Write-Host "`nG++ no PATH: $pathGpp"
          
          # Criar arquivo de teste
          $testCode = @"
          #include <iostream>
          int main() {
            std::cout << "Hello World" << std::endl;
            return 0;
          }
          "@
          
          Set-Content -Path "test.cpp" -Value $testCode
          Write-Host "`ntest.cpp criado"
          
          Write-Host "`nTestando compila√ß√£o com g++ do Qt..."
          
          # Tentar compilar com arquivo de log
          $logFile = "compile_error.log"
          & $qtGppPath -o test.exe test.cpp > $logFile 2>&1
          $exitCode = $LASTEXITCODE
          
          Write-Host "Exit code: $exitCode"
          
          if (Test-Path $logFile) {
            $logContent = Get-Content $logFile
            if ($logContent) {
              Write-Host "`nErro/Output:"
              Write-Host $logContent
            } else {
              Write-Host "(log vazio)"
            }
          }
          
          if (Test-Path "test.exe") {
            Write-Host "‚úî test.exe foi criado com sucesso!"
            Write-Host "`nTestando execut√°vel..."
            & .\test.exe | Write-Host
            Remove-Item test.cpp, test.exe, $logFile -Force -ErrorAction SilentlyContinue
            Write-Host "`n‚úî Compilador g++ do Qt funciona"
          } else {
            Write-Host "`n‚ùå test.exe n√£o foi criado"
            throw "Compila√ß√£o com g++ falhou"
          }
          Write-Host "Testando Qt includes..."
          
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) {
            throw "Qt5_Dir/Qt5_DIR n√£o definido pelo install-qt-action"
          }

          $qtTestCode = @"
          #include <QCoreApplication>
          int main(int argc, char *argv[]) {
            QCoreApplication app(argc, argv);
            return 0;
          }
          "@
          
          Set-Content -Path "test_qt.cpp" -Value $qtTestCode

          $qtPath = $qtRoot
          $compileArgs = @(
            "test_qt.cpp",
            "-I$qtPath\include",
            "-I$qtPath\include\QtCore",
            "-L$qtPath\lib",
            "-lQt5Core",
            "-o", "test_qt.exe"
          )
          
          Write-Host "Compilando teste Qt..."
          $output = & $qtGppPath @compileArgs 2>&1
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -ne 0) {
            Write-Host "‚ö†Ô∏è Compila√ß√£o Qt falhou! Exit code: $exitCode"
            Write-Host "Output:"
            $output | Write-Host
          } else {
            Write-Host "‚úî Qt include funciona"
          }
          
          Remove-Item test_qt.cpp, test_qt.exe -Force -ErrorAction SilentlyContinue

      - name: Compilar Qwt com MinGW
        shell: pwsh
        run: |
          Write-Host "Compilando Qwt com MinGW..."
          
          # Usar qwt/src/src.pro para compilar apenas a biblioteca
          $qwtProFile = "qwt/src/src.pro"
          if (-not (Test-Path $qwtProFile)) {
            throw "Arquivo $qwtProFile n√£o encontrado"
          }
          
          # PRIMEIRO: Limpar DLLs/libs MSVC antigas ANTES de compilar
          # (o build coloca o output diretamente em qwt/lib/ via DESTDIR)
          Write-Host "Limpando artefatos MSVC antigos de qwt/lib/..."
          Get-ChildItem -Path "qwt/lib" -Include "*.dll","*.lib","*.exp","*.ilk","*.pdb" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "  Removendo: $($_.Name)"
            Remove-Item -Path $_.FullName -Force
          }
          
          # Criar diret√≥rio para build do Qwt
          $qwtBuildDir = "qwt/build_mingw"
          if (Test-Path $qwtBuildDir) {
            Remove-Item -Path $qwtBuildDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $qwtBuildDir | Out-Null
          
          Push-Location $qwtBuildDir
          
          Write-Host "Executando qmake para Qwt..."
          $qmakeExe = (Get-Command qmake).Source
          $srcProFile = Resolve-Path "../src/src.pro" | Select-Object -ExpandProperty Path
          
          & $qmakeExe $srcProFile "CONFIG+=release" > qmake.log 2>&1
          $qmakeExit = $LASTEXITCODE
          if ($qmakeExit -ne 0) {
            Write-Host "‚ùå qmake falhou para Qwt. Log:"
            Get-Content qmake.log | Write-Host
            throw "qmake Qwt falhou"
          }
          
          Write-Host "Compilando Qwt com mingw32-make..."
          $makeExe = $env:QT_MINGW_MAKE
          if (-not $makeExe -or -not (Test-Path $makeExe)) {
            $makeExe = (Get-Command mingw32-make).Source
          }
          
          & $makeExe -f Makefile.Release 2>&1 | ForEach-Object { Write-Host $_ }
          if ($LASTEXITCODE -ne 0) {
            throw "mingw32-make Qwt falhou"
          }
          
          Write-Host "‚úî Qwt compilada com sucesso"
          Pop-Location
          
          # DESTDIR em src.pro = $${OUT_PWD}/../lib = qwt/lib/
          # A DLL MinGW j√° foi colocada diretamente em qwt/lib/ pelo build
          Write-Host "`nConte√∫do final de qwt/lib/:"
          Get-ChildItem -Path "qwt/lib" | ForEach-Object {
            Write-Host "  $($_.Name) - $($_.Length) bytes"
          }
          
          # Verificar se qwt.dll existe
          $qwtDll = Get-ChildItem -Path "qwt/lib" -Filter "qwt*.dll" -ErrorAction SilentlyContinue
          if (-not $qwtDll) {
            Write-Host "‚ö†Ô∏è qwt.dll n√£o encontrada em qwt/lib/. Procurando em build_mingw/..."
            $found = Get-ChildItem -Path "qwt/build_mingw" -Filter "qwt*.dll" -Recurse -ErrorAction SilentlyContinue
            if ($found) {
              foreach ($f in $found) {
                Write-Host "  Encontrada: $($f.FullName)"
                Copy-Item -Path $f.FullName -Destination "qwt/lib/" -Force
                Write-Host "  Copiada para qwt/lib/"
              }
            } else {
              # Listar tudo em build_mingw para diagn√≥stico
              Write-Host "Conte√∫do de qwt/build_mingw/:"
              Get-ChildItem -Path "qwt/build_mingw" -Recurse -File | ForEach-Object {
                Write-Host "  $($_.FullName) - $($_.Length) bytes"
              }
              throw "qwt.dll n√£o foi gerada pelo build!"
            }
          } else {
            Write-Host "‚úî qwt.dll encontrada: $($qwtDll.Name) ($($qwtDll.Length) bytes)"
          }

      - name: Criar diret√≥rio de build
        shell: pwsh
        run: |
          if (Test-Path "build") {
            Remove-Item -Path "build" -Recurse -Force
          }
          New-Item -ItemType Directory -Path "build" | Out-Null
          Write-Host "‚úî Diret√≥rio build criado"

      - name: Executar qmake
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Executando qmake..."
          Write-Host "Qt: $env:Qt5_DIR"
          Write-Host "qmake: $(Get-Command qmake -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source)"
          
          # Passar QWT_LOCATION via linha de comando do qmake (com caminho absoluto)
          $sourceDir = Resolve-Path ".." | Select-Object -ExpandProperty Path
          $qwtPath = Join-Path $sourceDir "qwt"
          $qmakeExe = (Get-Command qmake).Source
          
          Write-Host "Qwt path: $qwtPath"
          Write-Host "Rodando: $qmakeExe ..\IDS_DEStruct.pro CONFIG+=release QWT_LOCATION=$qwtPath"
          
          & $qmakeExe "..\IDS_DEStruct.pro" "CONFIG+=release" "QWT_LOCATION=$qwtPath" > qmake.log 2>&1
          $qmakeExit = $LASTEXITCODE
          
          Write-Host "`n--- QMake Output ---"
          if (Test-Path "qmake.log") {
            Get-Content "qmake.log" | Write-Host
          } else {
            Write-Host "(nenhum log gerado)"
          }
          
          if ($qmakeExit -ne 0) {
            throw "qmake falhou com c√≥digo: $qmakeExit"
          }
          
          # Verificar se Makefile foi gerado
          if (-not (Test-Path "Makefile")) {
            Write-Host "Conte√∫do do diret√≥rio build:"
            Get-ChildItem -Recurse | Select-Object FullName | Write-Host
            throw "qmake n√£o gerou Makefile"
          }
          Write-Host "‚úî qmake conclu√≠do - Makefile gerado"

      - name: Compilar com mingw32-make
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Compilando com mingw32-make..."
          
          $makeExe = $env:QT_MINGW_MAKE
          if (-not $makeExe -or -not (Test-Path $makeExe)) {
            $makeExe = (Get-Command mingw32-make).Source
          }
          Write-Host "Usando: $makeExe"
          
          Write-Host "`n--- Iniciando compila√ß√£o ---"
          & $makeExe -f Makefile.Release 2>&1 | ForEach-Object { Write-Host $_ }
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -ne 0) {
            throw "mingw32-make falhou com c√≥digo: $exitCode"
          }
          Write-Host "‚úî Compila√ß√£o conclu√≠da"

      - name: Localizar execut√°vel
        id: find-exe
        shell: pwsh
        run: |
          Write-Host "Procurando execut√°vel..."
          
          $exePaths = @(
            "build/release/IDS_DEStruct.exe",
            "build/release/IDS_DEStructd.exe",
            "build/IDS_DEStruct.exe",
            "build/release/bin/IDS_DEStruct.exe"
          )
          
          $exeFound = $null
          foreach ($path in $exePaths) {
            if (Test-Path $path) {
              $exeFound = (Resolve-Path $path).Path
              break
            }
          }
          
          if (-not $exeFound) {
            Write-Host "‚ùå Execut√°vel n√£o encontrado nos caminhos esperados"
            Write-Host "Procurando em toda a pasta build..."
            Get-ChildItem -Path "build" -Filter "*.exe" -Recurse | ForEach-Object {
              Write-Host "  Encontrado: $($_.FullName)"
            }
            throw "Execut√°vel n√£o encontrado"
          }
          
          Write-Host "‚úî Execut√°vel encontrado: $exeFound"
          
          $exeDir = Split-Path -Parent $exeFound
          "exe_path=$exeFound" >> $env:GITHUB_OUTPUT
          "exe_dir=$exeDir" >> $env:GITHUB_OUTPUT

      - name: Empacotar depend√™ncias (Qt + Qwt + MinGW runtime)
        shell: pwsh
        run: |
          # ============================================================
          # Deploy MANUAL de todas as depend√™ncias.
          # N√ÉO usamos windeployqt porque ele √© um app Qt que precisa
          # carregar qwindows.dll para funcionar, mas a instala√ß√£o via
          # aqtinstall tem paths internos errados (aponta para o path
          # original de build, n√£o para o path no runner), causando
          # falha "Unable to find platform plugin" de forma consistente.
          # ============================================================
          
          $exePath = "${{ steps.find-exe.outputs.exe_path }}"
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          
          # --- Resolver paths do Qt ---
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) { throw "Qt5_Dir/Qt5_DIR n√£o definido" }
          
          $qtBin     = Join-Path $qtRoot "bin"
          $qtPlugins = Join-Path $qtRoot "plugins"
          $mingwBin  = Split-Path -Parent $env:QT_GPP_PATH
          
          Write-Host "=== Configura√ß√£o ==="
          Write-Host "  Qt root:    $qtRoot"
          Write-Host "  Qt bin:     $qtBin"
          Write-Host "  Qt plugins: $qtPlugins"
          Write-Host "  MinGW bin:  $mingwBin"
          Write-Host "  Exe dir:    $exeDir"
          Write-Host ""
          
          # Verificar que os diret√≥rios fonte existem
          if (-not (Test-Path $qtBin))     { throw "Qt bin n√£o encontrado: $qtBin" }
          if (-not (Test-Path $qtPlugins)) { throw "Qt plugins n√£o encontrado: $qtPlugins" }
          if (-not (Test-Path $mingwBin))  { throw "MinGW bin n√£o encontrado: $mingwBin" }
          
          $errorCount = 0
          
          # ========================================
          # 1. DLLs do Qt (baseado em QT += no .pro)
          # ========================================
          Write-Host "=== 1. DLLs do Qt ==="
          $qtDlls = @(
            "Qt5Core.dll",
            "Qt5Gui.dll",
            "Qt5Widgets.dll",
            "Qt5OpenGL.dll",
            "Qt5Svg.dll",
            "Qt5PrintSupport.dll"
          )
          foreach ($dllName in $qtDlls) {
            $src = Join-Path $qtBin $dllName
            if (Test-Path $src) {
              Copy-Item -Path $src -Destination $exeDir -Force
              $sz = [math]::Round((Get-Item $src).Length / 1KB)
              Write-Host "  ‚úî $dllName (${sz} KB)"
            } else {
              Write-Host "  ‚ùå N√ÉO ENCONTRADO: $src"
              $errorCount++
            }
          }
          
          # ==========================================
          # 2. Plugins do Qt (platforms, imageformats, styles)
          # ==========================================
          Write-Host "`n=== 2. Plugins do Qt ==="
          
          # 2a. platforms/ (obrigat√≥rio - sem isso o app n√£o inicia)
          $platformDir = Join-Path $exeDir "platforms"
          New-Item -ItemType Directory -Path $platformDir -Force | Out-Null
          $qwindowsSrc = Join-Path $qtPlugins "platforms\qwindows.dll"
          if (Test-Path $qwindowsSrc) {
            Copy-Item -Path $qwindowsSrc -Destination $platformDir -Force
            Write-Host "  ‚úî platforms/qwindows.dll"
          } else {
            Write-Host "  ‚ùå platforms/qwindows.dll N√ÉO ENCONTRADO"
            $errorCount++
          }
          
          # 2b. imageformats/ (suporte a SVG, JPEG, ICO, etc.)
          $imageSrcDir = Join-Path $qtPlugins "imageformats"
          if (Test-Path $imageSrcDir) {
            $imageDir = Join-Path $exeDir "imageformats"
            New-Item -ItemType Directory -Path $imageDir -Force | Out-Null
            Get-ChildItem -Path $imageSrcDir -Filter "*.dll" | Where-Object {
              $_.Name -notlike "*d.dll" -and $_.Name -notlike "*_debug*"
            } | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination $imageDir -Force
              Write-Host "  ‚úî imageformats/$($_.Name)"
            }
          }
          
          # 2c. styles/ (windowsvista style, etc.)
          $stylesSrcDir = Join-Path $qtPlugins "styles"
          if (Test-Path $stylesSrcDir) {
            $stylesDir = Join-Path $exeDir "styles"
            New-Item -ItemType Directory -Path $stylesDir -Force | Out-Null
            Get-ChildItem -Path $stylesSrcDir -Filter "*.dll" | Where-Object {
              $_.Name -notlike "*d.dll" -and $_.Name -notlike "*_debug*"
            } | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination $stylesDir -Force
              Write-Host "  ‚úî styles/$($_.Name)"
            }
          }
          
          # 2d. iconengines/ (necess√°rio para √≠cones SVG)
          $iconSrcDir = Join-Path $qtPlugins "iconengines"
          if (Test-Path $iconSrcDir) {
            $iconDir = Join-Path $exeDir "iconengines"
            New-Item -ItemType Directory -Path $iconDir -Force | Out-Null
            Get-ChildItem -Path $iconSrcDir -Filter "*.dll" | Where-Object {
              $_.Name -notlike "*d.dll" -and $_.Name -notlike "*_debug*"
            } | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination $iconDir -Force
              Write-Host "  ‚úî iconengines/$($_.Name)"
            }
          }
          
          # ==========================================
          # 3. DLL do Qwt (compilada com MinGW)
          # ==========================================
          Write-Host "`n=== 3. DLL do Qwt ==="
          $qwtCopied = $false
          $qwtDlls = Get-ChildItem -Path "qwt/lib" -Filter "*.dll" -ErrorAction SilentlyContinue
          foreach ($dll in $qwtDlls) {
            if ($dll.Name -notlike "*d.dll" -and $dll.Name -notlike "*_debug*") {
              Copy-Item -Path $dll.FullName -Destination $exeDir -Force
              $sz = [math]::Round($dll.Length / 1KB)
              Write-Host "  ‚úî $($dll.Name) (${sz} KB)"
              $qwtCopied = $true
            }
          }
          if (-not $qwtCopied) {
            Write-Host "  ‚ùå Nenhuma DLL do Qwt encontrada em qwt/lib/"
            Write-Host "  Conte√∫do de qwt/lib/:"
            Get-ChildItem -Path "qwt/lib" -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "    $($_.Name) ($($_.Length) bytes)"
            }
            $errorCount++
          }
          
          # ==========================================
          # 4. MinGW runtime DLLs
          # ==========================================
          Write-Host "`n=== 4. MinGW runtime ==="
          $runtimeDlls = @("libgcc_s_seh-1.dll", "libstdc++-6.dll", "libwinpthread-1.dll")
          foreach ($dllName in $runtimeDlls) {
            $src = Join-Path $mingwBin $dllName
            if (Test-Path $src) {
              Copy-Item -Path $src -Destination $exeDir -Force
              Write-Host "  ‚úî $dllName"
            } else {
              Write-Host "  ‚ùå N√ÉO ENCONTRADO: $dllName em $mingwBin"
              $errorCount++
            }
          }
          
          # ==========================================
          # 5. Verifica√ß√£o final
          # ==========================================
          Write-Host "`n=== 5. Verifica√ß√£o final ==="
          $requiredFiles = @(
            "IDS_DEStruct.exe",
            "Qt5Core.dll",
            "Qt5Gui.dll",
            "Qt5Widgets.dll",
            "Qt5PrintSupport.dll",
            "Qt5Svg.dll",
            "platforms\qwindows.dll",
            "libgcc_s_seh-1.dll",
            "libstdc++-6.dll",
            "libwinpthread-1.dll"
          )
          # Adicionar qwt*.dll dinamicamente
          $qwtInDest = Get-ChildItem -Path $exeDir -Filter "qwt*.dll" -ErrorAction SilentlyContinue
          if ($qwtInDest) {
            $requiredFiles += $qwtInDest.Name
          } else {
            Write-Host "  ‚ùå qwt.dll ausente no destino!"
            $errorCount++
          }
          
          $allPresent = $true
          foreach ($file in $requiredFiles) {
            $fullPath = Join-Path $exeDir $file
            if (Test-Path $fullPath) {
              Write-Host "  ‚úî $file"
            } else {
              Write-Host "  ‚ùå AUSENTE: $file"
              $allPresent = $false
              $errorCount++
            }
          }
          
          Write-Host "`n=== Invent√°rio completo ==="
          Get-ChildItem -Path $exeDir -Recurse -File | ForEach-Object {
            $rel = $_.FullName.Substring($exeDir.Length + 1)
            $sz = [math]::Round($_.Length / 1KB)
            Write-Host "  $rel (${sz} KB)"
          }
          
          if ($errorCount -gt 0) {
            Write-Host "`n‚ö†Ô∏è $errorCount erro(s) encontrado(s) durante o empacotamento"
            if (-not $allPresent) {
              throw "Arquivos obrigat√≥rios ausentes no pacote!"
            }
          } else {
            Write-Host "`n‚úî Todas as depend√™ncias empacotadas com sucesso"
          }

      - name: Criar pacote ZIP
        shell: pwsh
        run: |
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          $releaseDir = "release"
          $zipPath = Join-Path $releaseDir $env:ZIP_NAME
          
          if (-not (Test-Path $releaseDir)) {
            New-Item -ItemType Directory -Path $releaseDir | Out-Null
          }
          
          if (Test-Path $zipPath) {
            Remove-Item $zipPath -Force
          }
          
          Write-Host "Criando ZIP: $zipPath"
          Compress-Archive -Path "$exeDir\*" -DestinationPath $zipPath
          
          if (-not (Test-Path $zipPath)) {
            throw "Falha ao criar ZIP"
          }
          
          $zipSize = (Get-Item $zipPath).Length / 1MB
          Write-Host "‚úî ZIP criado com sucesso: $([math]::Round($zipSize, 2)) MB"
          
          "zip_path=$zipPath" >> $env:GITHUB_OUTPUT

      - name: Upload artefato
        uses: actions/upload-artifact@v4
        with:
          name: IDS_DEStruct-${{ env.VERSION }}-windows-x64
          path: release/${{ env.ZIP_NAME }}
          if-no-files-found: error

      - name: Criar Release no GitHub
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION }}
          name: IDS_DEStruct ${{ env.VERSION }} (Windows x64)
          body: |
            ${{ github.event.inputs.notes }}
            
            ## üì¶ Download
            - **Windows x64 (MinGW)**: `${{ env.ZIP_NAME }}`
            
            ## üîß Requisitos
            - Windows 10/11 64-bit
            - Todas as DLLs necess√°rias est√£o inclu√≠das no pacote
            
            ## üìù Changelog
            Veja as mudan√ßas nesta vers√£o nos commits abaixo.
          prerelease: ${{ github.event.inputs.prerelease }}
          files: release/${{ env.ZIP_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
