name: Build & Release (Windows MinGW, portable) - IDS_DEStruct

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Vers√£o/Tag (ex.: v1.0.0)"
        required: true
        type: string
      prerelease:
        description: "Marcar como pr√©-release?"
        required: false
        default: false
        type: boolean
      notes:
        description: "Notas da release (opcional)"
        required: false
        type: string

permissions:
  contents: write

env:
  VERSION: ${{ github.event.inputs.version }}
  QT_VERSION: "5.15.2"
  ZIP_NAME: IDS_DEStruct-${{ github.event.inputs.version }}-windows-x64.zip

jobs:
  build-windows-mingw:
    name: Windows (MinGW + Qt5 + Qwt local)
    runs-on: windows-latest

    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Instalar Qt5
        uses: jurplel/install-qt-action@v3
        with:
          version: ${{ env.QT_VERSION }}
          host: windows
          target: desktop
          arch: win64_mingw81
          cache: true

      - name: Configurar vari√°veis de ambiente do MinGW do Qt
        shell: pwsh
        run: |
          Write-Host "Configurando ambiente MinGW..."
          
          $mingwPath = "D:\a\IDS_DEStruct\Qt\5.15.2\mingw81_64\bin"
          
          if (Test-Path $mingwPath) {
            Write-Host "‚úî Caminho MinGW encontrado: $mingwPath"
            
            # Adicionar ao PATH (PowerShell)
            $env:PATH = "$mingwPath;$env:PATH"
            
            # Adicionar ao GITHUB_PATH para passos subsequentes
            Add-Content -Path $env:GITHUB_PATH -Value $mingwPath
            
            Write-Host "‚úî MinGW adicionado ao PATH"
            Write-Host "`nVerificando ferramentas:"
            Write-Host "g++: $(Get-Command g++ | Select-Object -ExpandProperty Source)"
            Write-Host "mingw32-make: $(Get-Command mingw32-make | Select-Object -ExpandProperty Source)"
          } else {
            throw "Caminho MinGW n√£o encontrado: $mingwPath"
          }

      - name: Validar vers√£o
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace($env:VERSION)) {
            throw "Vers√£o n√£o informada"
          }
          Write-Host "‚úî Vers√£o/Tag: $env:VERSION"

      - name: Verificar estrutura do projeto
        shell: pwsh
        run: |
          Write-Host "Verificando arquivos do projeto..."
          if (-not (Test-Path "IDS_DEStruct.pro")) {
            throw "IDS_DEStruct.pro n√£o encontrado"
          }
          if (-not (Test-Path "qwt")) {
            throw "Pasta qwt/ n√£o encontrada"
          }
          if (-not (Test-Path "qwt/lib")) {
            throw "Pasta qwt/lib/ n√£o encontrada"
          }
          if (-not (Test-Path "qwt/src")) {
            throw "Pasta qwt/src/ n√£o encontrada"
          }
          Write-Host "‚úî Estrutura do projeto OK"
          Write-Host "Conte√∫do de qwt/lib:"
          Get-ChildItem -Path "qwt/lib" | Select-Object Name

      - name: Testar compilador g++
        shell: pwsh
        run: |
          Write-Host "Testando compilador g++..."
          
          # Encontrar o g++ correto do Qt
          $qtGppPath = "D:\a\IDS_DEStruct\Qt\5.15.2\mingw81_64\bin\g++.exe"
          
          if (Test-Path $qtGppPath) {
            Write-Host "‚úî Encontrado g++ do Qt: $qtGppPath"
            Write-Host "Vers√£o:"
            & $qtGppPath --version | Write-Host
          } else {
            Write-Host "‚ùå g++ do Qt n√£o encontrado em $qtGppPath"
          }
          
          # Tamb√©m verificar o que est√° no PATH
          $pathGpp = (Get-Command g++ -ErrorAction SilentlyContinue).Source
          Write-Host "`nG++ no PATH: $pathGpp"
          
          # Criar arquivo de teste
          $testCode = @"
#include <iostream>
int main() {
  std::cout << "Hello World" << std::endl;
  return 0;
}
"@
          
          Set-Content -Path "test.cpp" -Value $testCode
          Write-Host "`ntest.cpp criado"
          
          Write-Host "`nTestando compila√ß√£o com g++ do Qt..."
          
          # Tentar compilar com arquivo de log
          $logFile = "compile_error.log"
          & $qtGppPath -o test.exe test.cpp > $logFile 2>&1
          $exitCode = $LASTEXITCODE
          
          Write-Host "Exit code: $exitCode"
          
          if (Test-Path $logFile) {
            $logContent = Get-Content $logFile
            if ($logContent) {
              Write-Host "`nErro/Output:"
              Write-Host $logContent
            } else {
              Write-Host "(log vazio)"
            }
          }
          
          if (Test-Path "test.exe") {
            Write-Host "‚úî test.exe foi criado com sucesso!"
            Write-Host "`nTestando execut√°vel..."
            & .\test.exe | Write-Host
            Remove-Item test.cpp, test.exe, $logFile -Force -ErrorAction SilentlyContinue
            Write-Host "`n‚úî Compilador g++ do Qt funciona"
          } else {
            Write-Host "`n‚ùå test.exe n√£o foi criado"
            throw "Compila√ß√£o com g++ falhou"
          }
          Write-Host "Testando Qt includes..."
          
          $qtTestCode = @"
          #include <QCoreApplication>
          int main(int argc, char *argv[]) {
            QCoreApplication app(argc, argv);
            return 0;
          }
          "@
          
          Set-Content -Path "test_qt.cpp" -Value $qtTestCode
          
          $qtPath = "D:\a\IDS_DEStruct\Qt\5.15.2\mingw81_64"
          $compileArgs = @(
            "-I$qtPath\include",
            "-I$qtPath\include\QtCore",
            "-o", "test_qt.exe",
            "test_qt.cpp"
          )
          
          Write-Host "Compilando teste Qt..."
          $output = & g++ @compileArgs 2>&1
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -ne 0) {
            Write-Host "‚ö†Ô∏è Compila√ß√£o Qt falhou! Exit code: $exitCode"
            Write-Host "Output:"
            $output | Write-Host
          } else {
            Write-Host "‚úî Qt include funciona"
          }
          
          Remove-Item test_qt.cpp, test_qt.exe -Force -ErrorAction SilentlyContinue

      - name: Criar diret√≥rio de build
        shell: pwsh
        run: |
          if (Test-Path "build") {
            Remove-Item -Path "build" -Recurse -Force
          }
          New-Item -ItemType Directory -Path "build" | Out-Null
          Write-Host "‚úî Diret√≥rio build criado"

      - name: Executar qmake
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Executando qmake..."
          Write-Host "Qt: $env:Qt5_DIR"
          Write-Host "qmake: $(Get-Command qmake -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source)"
          
          # Passar QWT_LOCATION via linha de comando do qmake
          $parentDir = Resolve-Path ".." | Select-Object -ExpandProperty Path
          qmake "..\IDS_DEStruct.pro" "CONFIG+=release" "QWT_LOCATION=$parentDir/qwt" 2>&1 | Tee-Object -FilePath "qmake.log"
          
          Write-Host "`n--- QMake Output (√∫ltimas 30 linhas) ---"
          Get-Content "qmake.log" | Select-Object -Last 30 | Write-Host
          
          if ($LASTEXITCODE -ne 0) {
            throw "qmake falhou com c√≥digo: $LASTEXITCODE"
          }
          Write-Host "‚úî qmake conclu√≠do"

      - name: Verificar arquivos gerados pelo uic
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Verificando arquivos gerados..."
          
          $uiFiles = @(
            "ui/release/ui_imainwindow.h",
            "ui/release/ui_icarregar.h",
            "ui/release/ui_dialogMaxMin.h",
            "ui/release/ui_dialogConfig.h",
            "ui/release/ui_dialogDecimacao.h"
          )
          
          foreach ($file in $uiFiles) {
            if (Test-Path $file) {
              $size = (Get-Item $file).Length
              Write-Host "‚úî $file ($size bytes)"
              
              # Verificar se tem conte√∫do v√°lido
              $content = Get-Content $file -TotalCount 5
              Write-Host "  Primeiras linhas:"
              $content | Write-Host
            } else {
              Write-Host "‚ùå ARQUIVO N√ÉO ENCONTRADO: $file"
            }
          }

      - name: Compilar apenas main.cpp com verbose
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Tentando compilar main.cpp isoladamente..."
          
          # Compilar manualmente
          Write-Host "`n--- Tentativa de compila√ß√£o manual ---"
          
          $compileArgs = @(
            "-c",
            "-fno-keep-inline-dllexport",
            "-O2",
            "-std=gnu++11",
            "-Wall",
            "-Wextra",
            "-fexceptions",
            "-mthreads",
            "-DUNICODE",
            "-D_UNICODE",
            "-DWIN32",
            "-DMINGW_HAS_SECURE_API=1",
            "-DQT_DLL",
            "-DQWT_DLL",
            "-DQT_NO_DEBUG",
            "-DQT_OPENGL_LIB",
            "-DQT_SVG_LIB",
            "-DQT_PRINTSUPPORT_LIB",
            "-DQT_WIDGETS_LIB",
            "-DQT_GUI_LIB",
            "-DQT_CORE_LIB",
            "-DQT_NEEDS_QMAIN",
            "-I../../IDS_DEStruct",
            "-I.",
            "-I../qwt/src",
            "-I../../Qt/5.15.2/mingw81_64/include",
            "-I../../Qt/5.15.2/mingw81_64/include/QtCore",
            "-I../../Qt/5.15.2/mingw81_64/include/QtGui",
            "-I../../Qt/5.15.2/mingw81_64/include/QtWidgets",
            "-Imoc/release",
            "-Iui/release",
            "../main.cpp",
            "-o",
            "obj/release/main.o"
          )
          
          Write-Host "g++ $($compileArgs -join ' ')`n"
          
          $output = & g++ @compileArgs 2>&1
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -ne 0) {
            Write-Host "‚ùå Compila√ß√£o de main.cpp falhou (exit code: $exitCode)"
            Write-Host "`n--- Erro de compila√ß√£o ---"
            $output | Write-Host
            throw "Compila√ß√£o de main.cpp falhou"
          } else {
            Write-Host "‚úî main.cpp compilou com sucesso"
          }

      - name: Compilar com mingw32-make
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Compilando com mingw32-make..."
          
          # Criar arquivo de log
          $logFile = "build.log"
          
          Write-Host "`n--- Iniciando compila√ß√£o (output ser√° salvo em $logFile) ---"
          # Executar make e redirecionar tudo para um arquivo
          mingw32-make -f Makefile.Release 2>&1 | Tee-Object -FilePath $logFile
          
          $exitCode = $LASTEXITCODE
          
          # Ler o arquivo de log e exibir
          Write-Host "`n--- FULL LOG FILE CONTENT ---"
          Get-Content $logFile | Write-Host
          
          Write-Host "`n--- Procurando por erros ---"
          $errors = Get-Content $logFile | Select-String -Pattern "error:|undefined reference|cannot find" -Context 2,2
          if ($errors) {
            Write-Host "Erros encontrados:"
            $errors | Write-Host
          }
          
          if ($exitCode -ne 0) {
            throw "mingw32-make falhou com c√≥digo: $exitCode"
          }
          Write-Host "‚úî Compila√ß√£o conclu√≠da"

      - name: Localizar execut√°vel
        id: find-exe
        shell: pwsh
        run: |
          Write-Host "Procurando execut√°vel..."
          
          $exePaths = @(
            "build/release/IDS_DEStruct.exe",
            "build/release/IDS_DEStructd.exe",
            "build/IDS_DEStruct.exe",
            "build/release/bin/IDS_DEStruct.exe"
          )
          
          $exeFound = $null
          foreach ($path in $exePaths) {
            if (Test-Path $path) {
              $exeFound = (Resolve-Path $path).Path
              break
            }
          }
          
          if (-not $exeFound) {
            Write-Host "‚ùå Execut√°vel n√£o encontrado nos caminhos esperados"
            Write-Host "Procurando em toda a pasta build..."
            Get-ChildItem -Path "build" -Filter "*.exe" -Recurse | ForEach-Object {
              Write-Host "  Encontrado: $($_.FullName)"
            }
            throw "Execut√°vel n√£o encontrado"
          }
          
          Write-Host "‚úî Execut√°vel encontrado: $exeFound"
          
          $exeDir = Split-Path -Parent $exeFound
          "exe_path=$exeFound" >> $env:GITHUB_OUTPUT
          "exe_dir=$exeDir" >> $env:GITHUB_OUTPUT

      - name: Copiar DLLs do Qwt
        shell: pwsh
        run: |
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          Write-Host "Copiando DLLs do Qwt para: $exeDir"
          
          $qwtDlls = Get-ChildItem -Path "qwt/lib" -Filter "*.dll"
          foreach ($dll in $qwtDlls) {
            Copy-Item -Path $dll.FullName -Destination $exeDir -Force
            Write-Host "  Copiado: $($dll.Name)"
          }
          Write-Host "‚úî DLLs do Qwt copiadas"

      - name: windeployqt (incluir DLLs do Qt)
        shell: pwsh
        run: |
          $exePath = "${{ steps.find-exe.outputs.exe_path }}"
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          
          Write-Host "Executando windeployqt em: $exePath"
          
          windeployqt --release --no-translations --no-system-d3d-compiler --no-opengl-sw "$exePath"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ö†Ô∏è windeployqt retornou c√≥digo: $LASTEXITCODE (continuando...)"
          } else {
            Write-Host "‚úî windeployqt conclu√≠do"
          }
          
          Write-Host "`nConte√∫do do diret√≥rio do execut√°vel:"
          Get-ChildItem -Path $exeDir | Select-Object Name, Length

      - name: Criar pacote ZIP
        shell: pwsh
        run: |
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          $releaseDir = "release"
          $zipPath = Join-Path $releaseDir $env:ZIP_NAME
          
          if (-not (Test-Path $releaseDir)) {
            New-Item -ItemType Directory -Path $releaseDir | Out-Null
          }
          
          if (Test-Path $zipPath) {
            Remove-Item $zipPath -Force
          }
          
          Write-Host "Criando ZIP: $zipPath"
          Compress-Archive -Path "$exeDir\*" -DestinationPath $zipPath
          
          if (-not (Test-Path $zipPath)) {
            throw "Falha ao criar ZIP"
          }
          
          $zipSize = (Get-Item $zipPath).Length / 1MB
          Write-Host "‚úî ZIP criado com sucesso: $([math]::Round($zipSize, 2)) MB"
          
          "zip_path=$zipPath" >> $env:GITHUB_OUTPUT

      - name: Upload artefato
        uses: actions/upload-artifact@v4
        with:
          name: IDS_DEStruct-${{ env.VERSION }}-windows-x64
          path: release/${{ env.ZIP_NAME }}
          if-no-files-found: error

      - name: Criar Release no GitHub
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION }}
          name: IDS_DEStruct ${{ env.VERSION }} (Windows x64)
          body: |
            ${{ github.event.inputs.notes }}
            
            ## üì¶ Download
            - **Windows x64 (MinGW)**: `${{ env.ZIP_NAME }}`
            
            ## üîß Requisitos
            - Windows 10/11 64-bit
            - Todas as DLLs necess√°rias est√£o inclu√≠das no pacote
            
            ## üìù Changelog
            Veja as mudan√ßas nesta vers√£o nos commits abaixo.
          prerelease: ${{ github.event.inputs.prerelease }}
          files: release/${{ env.ZIP_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
