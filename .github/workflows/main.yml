name: Build & Release (Windows MinGW, portable) - IDS_DEStruct

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Vers√£o/Tag (ex.: v1.0.0)"
        required: true
        type: string
      prerelease:
        description: "Marcar como pr√©-release?"
        required: false
        default: false
        type: boolean
      notes:
        description: "Notas da release (opcional)"
        required: false
        type: string

permissions:
  contents: write

env:
  VERSION: ${{ github.event.inputs.version }}
  QT_VERSION: "5.15.2"
  ZIP_NAME: IDS_DEStruct-${{ github.event.inputs.version }}-windows-x64.zip

jobs:
  build-windows-mingw:
    name: Windows (MinGW + Qt5 + Qwt local)
    runs-on: windows-latest

    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Instalar Qt5
        uses: jurplel/install-qt-action@v3
        with:
          version: ${{ env.QT_VERSION }}
          host: windows
          target: desktop
          arch: win64_mingw81
          tools: 'tools_mingw'
          cache: true

      - name: Garantir MinGW toolchain (aqt)
        shell: pwsh
        run: |
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) {
            throw "Qt5_Dir/Qt5_DIR n√£o definido pelo install-qt-action"
          }
          $qtBase = Split-Path -Parent (Split-Path -Parent $qtRoot)
          $mingwToolBin = Join-Path $qtBase "Tools\mingw810_64\bin"
          $gppPath = Join-Path $mingwToolBin "g++.exe"

          if (-not (Test-Path $gppPath)) {
            Write-Host "MinGW toolchain nao encontrado. Instalando via aqt..."
            Write-Host "Listando variantes disponiveis de tools_mingw..."
            $variants = python -m aqt list-tool windows desktop tools_mingw
            $variant = ($variants | Where-Object { $_ -match '^mingw' } | Select-Object -First 1)
            if (-not $variant) {
              Write-Host "Nao foi possivel detectar variante do tools_mingw."
              Write-Host $variants
              throw "tools_mingw sem variantes disponiveis"
            }
            Write-Host "Usando variante: $variant"
            python -m aqt install-tool windows desktop tools_mingw $variant --outputdir $qtBase
          }

          if (-not (Test-Path $gppPath)) {
            Write-Host "Falha ao encontrar g++.exe em $mingwToolBin"
            if (Test-Path (Join-Path $qtBase "Tools")) {
              Get-ChildItem -Path (Join-Path $qtBase "Tools") -Directory | Select-Object Name | Write-Host
            }
            throw "MinGW toolchain nao instalado"
          }
          Write-Host "‚úî MinGW toolchain OK: $mingwToolBin"

      - name: Configurar vari√°veis de ambiente do MinGW do Qt
        shell: pwsh
        run: |
          Write-Host "Configurando ambiente MinGW..."
          
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) {
            throw "Qt5_Dir/Qt5_DIR n√£o definido pelo install-qt-action"
          }
          $qtBase = Split-Path -Parent (Split-Path -Parent $qtRoot)
          $qtBin = Join-Path $qtRoot "bin"
          $toolsRoot = Join-Path $qtBase "Tools"

          $toolsMingwBin = Join-Path $toolsRoot "mingw810_64\bin"

          $gppPath = Join-Path $qtBin "g++.exe"
          $makePath = Join-Path $qtBin "mingw32-make.exe"

          if (-not (Test-Path $gppPath) -or -not (Test-Path $makePath)) {
            Write-Host "g++/mingw32-make n√£o encontrados em $qtBin. Procurando em $toolsRoot..."
            if (Test-Path $toolsMingwBin) {
              $gppPath = Join-Path $toolsMingwBin "g++.exe"
              $makePath = Join-Path $toolsMingwBin "mingw32-make.exe"
            } elseif (Test-Path $toolsRoot) {
              $gppFound = Get-ChildItem -Path $toolsRoot -Filter "g++.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              $makeFound = Get-ChildItem -Path $toolsRoot -Filter "mingw32-make.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($gppFound) { $gppPath = $gppFound.FullName }
              if ($makeFound) { $makePath = $makeFound.FullName }
            }
          }

          if (-not (Test-Path $gppPath)) {
            throw "g++ n√£o encontrado (Qt bin ou Tools)."
          }
          if (-not (Test-Path $makePath)) {
            throw "mingw32-make n√£o encontrado (Qt bin ou Tools)."
          }

          $mingwBin = Split-Path -Parent $gppPath
          Write-Host "‚úî MinGW encontrado: $mingwBin"

          # Adicionar ao PATH (PowerShell)
          $env:PATH = "$mingwBin;$env:PATH"

          # Adicionar ao GITHUB_PATH para passos subsequentes
          Add-Content -Path $env:GITHUB_PATH -Value $mingwBin

          # Exportar caminhos para outros passos
          "QT_GPP_PATH=$gppPath" | Out-File -FilePath $env:GITHUB_ENV -Append
          "QT_MINGW_MAKE=$makePath" | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "‚úî MinGW adicionado ao PATH"
          Write-Host "g++: $gppPath"
          Write-Host "mingw32-make: $makePath"

      - name: Validar vers√£o
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace($env:VERSION)) {
            throw "Vers√£o n√£o informada"
          }
          Write-Host "‚úî Vers√£o/Tag: $env:VERSION"

      - name: Verificar estrutura do projeto
        shell: pwsh
        run: |
          Write-Host "Verificando arquivos do projeto..."
          if (-not (Test-Path "IDS_DEStruct.pro")) {
            throw "IDS_DEStruct.pro n√£o encontrado"
          }
          if (-not (Test-Path "qwt")) {
            throw "Pasta qwt/ n√£o encontrada"
          }
          if (-not (Test-Path "qwt/lib")) {
            throw "Pasta qwt/lib/ n√£o encontrada"
          }
          if (-not (Test-Path "qwt/src")) {
            throw "Pasta qwt/src/ n√£o encontrada"
          }
          Write-Host "‚úî Estrutura do projeto OK"
          Write-Host "Conte√∫do de qwt/lib:"
          Get-ChildItem -Path "qwt/lib" | Select-Object Name

      - name: Testar compilador g++
        shell: pwsh
        run: |
          Write-Host "Testando compilador g++..."
          
          # Usar g++ encontrado na etapa anterior
          $qtGppPath = $env:QT_GPP_PATH
          if (-not $qtGppPath) {
            throw "QT_GPP_PATH n√£o definido"
          }
          
          if (Test-Path $qtGppPath) {
            Write-Host "‚úî Encontrado g++ do Qt: $qtGppPath"
            Write-Host "Vers√£o:"
            & $qtGppPath --version | Write-Host
          } else {
            Write-Host "‚ùå g++ do Qt n√£o encontrado em $qtGppPath"
          }
          
          # Tamb√©m verificar o que est√° no PATH
          $pathGpp = (Get-Command g++ -ErrorAction SilentlyContinue).Source
          Write-Host "`nG++ no PATH: $pathGpp"
          
          # Criar arquivo de teste
          $testCode = @"
          #include <iostream>
          int main() {
            std::cout << "Hello World" << std::endl;
            return 0;
          }
          "@
          
          Set-Content -Path "test.cpp" -Value $testCode
          Write-Host "`ntest.cpp criado"
          
          Write-Host "`nTestando compila√ß√£o com g++ do Qt..."
          
          # Tentar compilar com arquivo de log
          $logFile = "compile_error.log"
          & $qtGppPath -o test.exe test.cpp > $logFile 2>&1
          $exitCode = $LASTEXITCODE
          
          Write-Host "Exit code: $exitCode"
          
          if (Test-Path $logFile) {
            $logContent = Get-Content $logFile
            if ($logContent) {
              Write-Host "`nErro/Output:"
              Write-Host $logContent
            } else {
              Write-Host "(log vazio)"
            }
          }
          
          if (Test-Path "test.exe") {
            Write-Host "‚úî test.exe foi criado com sucesso!"
            Write-Host "`nTestando execut√°vel..."
            & .\test.exe | Write-Host
            Remove-Item test.cpp, test.exe, $logFile -Force -ErrorAction SilentlyContinue
            Write-Host "`n‚úî Compilador g++ do Qt funciona"
          } else {
            Write-Host "`n‚ùå test.exe n√£o foi criado"
            throw "Compila√ß√£o com g++ falhou"
          }
          Write-Host "Testando Qt includes..."
          
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) {
            throw "Qt5_Dir/Qt5_DIR n√£o definido pelo install-qt-action"
          }

          $qtTestCode = @"
          #include <QCoreApplication>
          int main(int argc, char *argv[]) {
            QCoreApplication app(argc, argv);
            return 0;
          }
          "@
          
          Set-Content -Path "test_qt.cpp" -Value $qtTestCode

          $qtPath = $qtRoot
          $compileArgs = @(
            "test_qt.cpp",
            "-I$qtPath\include",
            "-I$qtPath\include\QtCore",
            "-L$qtPath\lib",
            "-lQt5Core",
            "-o", "test_qt.exe"
          )
          
          Write-Host "Compilando teste Qt..."
          $output = & $qtGppPath @compileArgs 2>&1
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -ne 0) {
            Write-Host "‚ö†Ô∏è Compila√ß√£o Qt falhou! Exit code: $exitCode"
            Write-Host "Output:"
            $output | Write-Host
          } else {
            Write-Host "‚úî Qt include funciona"
          }
          
          Remove-Item test_qt.cpp, test_qt.exe -Force -ErrorAction SilentlyContinue

      - name: Criar diret√≥rio de build
        shell: pwsh
        run: |
          if (Test-Path "build") {
            Remove-Item -Path "build" -Recurse -Force
          }
          New-Item -ItemType Directory -Path "build" | Out-Null
          Write-Host "‚úî Diret√≥rio build criado"

      - name: Executar qmake
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Executando qmake..."
          Write-Host "Qt: $env:Qt5_DIR"
          Write-Host "qmake: $(Get-Command qmake -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Source)"
          
          # Passar QWT_LOCATION via linha de comando do qmake (com caminho absoluto)
          $sourceDir = Resolve-Path ".." | Select-Object -ExpandProperty Path
          $qwtPath = Join-Path $sourceDir "qwt"
          $qmakeExe = (Get-Command qmake).Source
          
          Write-Host "Qwt path: $qwtPath"
          Write-Host "Rodando: $qmakeExe ..\IDS_DEStruct.pro CONFIG+=release QWT_LOCATION=$qwtPath"
          
          & $qmakeExe "..\IDS_DEStruct.pro" "CONFIG+=release" "QWT_LOCATION=$qwtPath" > qmake.log 2>&1
          $qmakeExit = $LASTEXITCODE
          
          Write-Host "`n--- QMake Output ---"
          if (Test-Path "qmake.log") {
            Get-Content "qmake.log" | Write-Host
          } else {
            Write-Host "(nenhum log gerado)"
          }
          
          if ($qmakeExit -ne 0) {
            throw "qmake falhou com c√≥digo: $qmakeExit"
          }
          
          # Verificar se Makefile foi gerado
          if (-not (Test-Path "Makefile")) {
            Write-Host "Conte√∫do do diret√≥rio build:"
            Get-ChildItem -Recurse | Select-Object FullName | Write-Host
            throw "qmake n√£o gerou Makefile"
          }
          Write-Host "‚úî qmake conclu√≠do - Makefile gerado"

      - name: Verificar biblioteca Qwt
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Verificando biblioteca Qwt..."
          Write-Host "Conte√∫do de ../qwt/lib:"
          $qwtLibFiles = Get-ChildItem -Path "../qwt/lib" -ErrorAction SilentlyContinue
          
          if (-not $qwtLibFiles) {
            Write-Host "‚ùå Nenhum arquivo encontrado em ../qwt/lib"
            Write-Host "Conte√∫do de ../qwt:"
            Get-ChildItem -Path "../qwt" -Recurse | Select-Object -ExpandProperty FullName | Write-Host
          } else {
            foreach ($file in $qwtLibFiles) {
              Write-Host "  $($file.Name) - $($file.Length) bytes"
              
              # Tentar determinar o tipo de biblioteca
              $filePath = $file.FullName
              
              # Se √© .a (est√°tica MinGW), pode ser listada com nm
              if ($file.Name -match '\.a$') {
                Write-Host "    Tipo: Arquivo est√°tico (.a)"
                Write-Host "    Tentando listar s√≠mbolos..."
                $nmExe = "$env:QT_MINGW_PATH\nm.exe"
                if (Test-Path $nmExe) {
                  & $nmExe --undefined-only $filePath 2>&1 | Select-Object -First 5 | Write-Host
                }
              } elseif ($file.Name -match '\.lib$') {
                Write-Host "    Tipo: Arquivo de importa√ß√£o (.lib) - prov√°vel MSVC!"
              } elseif ($file.Name -match '\.dll$') {
                Write-Host "    Tipo: DLL din√¢mica"
              }
            }
          }
          
          Write-Host "`nConte√∫do de Makefile.Release (procurando por -lqwt):"
          Select-String -Path "Makefile.Release" -Pattern "lqwt|QWT|qwt" | Select-Object -First 5 | Write-Host

      - name: Compilar Qwt com MinGW (se necess√°rio)
        shell: pwsh
        run: |
          Write-Host "Verificando se precisa compilar Qwt..."
          
          # Verificar se a biblioteca Qwt compat√≠vel com MinGW existe
          $qwtLibs = Get-ChildItem -Path "qwt/lib" -Filter "*.a" -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*qwt*" }
          
          if (-not $qwtLibs -or $qwtLibs.Length -eq 0) {
            Write-Host "‚ö†Ô∏è Biblioteca Qwt compat√≠vel com MinGW n√£o encontrada. Compilando Qwt..."
            
            # Usar qwt/src/src.pro para compilar apenas a biblioteca
            $qwtProFile = "qwt/src/src.pro"
            if (-not (Test-Path $qwtProFile)) {
              throw "Arquivo $qwtProFile n√£o encontrado"
            }
            
            # Criar diret√≥rio para build do Qwt
            $qwtBuildDir = "qwt/build_mingw"
            if (Test-Path $qwtBuildDir) {
              Remove-Item -Path $qwtBuildDir -Recurse -Force
            }
            New-Item -ItemType Directory -Path $qwtBuildDir | Out-Null
            
            Push-Location $qwtBuildDir
            
            Write-Host "Executando qmake para Qwt (src/src.pro)..."
            $qmakeExe = (Get-Command qmake).Source
            $srcProFile = Resolve-Path "../src/src.pro" | Select-Object -ExpandProperty Path
            
            & $qmakeExe $srcProFile "CONFIG+=release" > qmake.log 2>&1
            if ($LASTEXITCODE -ne 0) {
              Write-Host "‚ùå qmake falhou para Qwt. Log:"
              Get-Content qmake.log | Write-Host
              throw "qmake Qwt falhou"
            }
            
            Write-Host "Compilando Qwt com mingw32-make..."
            $makeExe = $env:QT_MINGW_MAKE
            if (-not $makeExe -or -not (Test-Path $makeExe)) {
              $makeExe = (Get-Command mingw32-make).Source
            }
            
            & $makeExe -f Makefile.Release 2>&1 | ForEach-Object { Write-Host $_ }
            if ($LASTEXITCODE -ne 0) {
              throw "mingw32-make Qwt falhou"
            }
            
            Write-Host "‚úî Qwt compilada com sucesso"
            
            # Copiar/Verificar biblioteca foi criada
            Write-Host "Localizando biblioteca compilada..."
            $compiledLibs = Get-ChildItem -Path "." -Filter "*qwt*.a" -Recurse
            if ($compiledLibs) {
              Write-Host "Encontrado(s):"
              foreach ($lib in $compiledLibs) {
                Write-Host "  $($lib.FullName)"
              }
            } else {
              Write-Host "‚ö†Ô∏è Nenhuma biblioteca .a encontrada. Verifique o build do Qwt."
            }
            
            Pop-Location
          } else {
            Write-Host "‚úî Biblioteca Qwt compat√≠vel encontrada"
          }

      - name: Compilar com mingw32-make
        shell: pwsh
        working-directory: build
        run: |
          Write-Host "Compilando com mingw32-make..."
          
          $makeExe = $env:QT_MINGW_MAKE
          if (-not $makeExe -or -not (Test-Path $makeExe)) {
            $makeExe = (Get-Command mingw32-make).Source
          }
          Write-Host "Usando: $makeExe"
          
          Write-Host "`n--- Iniciando compila√ß√£o ---"
          & $makeExe -f Makefile.Release 2>&1 | ForEach-Object { Write-Host $_ }
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -ne 0) {
            throw "mingw32-make falhou com c√≥digo: $exitCode"
          }
          Write-Host "‚úî Compila√ß√£o conclu√≠da"

      - name: Localizar execut√°vel
        id: find-exe
        shell: pwsh
        run: |
          Write-Host "Procurando execut√°vel..."
          
          $exePaths = @(
            "build/release/IDS_DEStruct.exe",
            "build/release/IDS_DEStructd.exe",
            "build/IDS_DEStruct.exe",
            "build/release/bin/IDS_DEStruct.exe"
          )
          
          $exeFound = $null
          foreach ($path in $exePaths) {
            if (Test-Path $path) {
              $exeFound = (Resolve-Path $path).Path
              break
            }
          }
          
          if (-not $exeFound) {
            Write-Host "‚ùå Execut√°vel n√£o encontrado nos caminhos esperados"
            Write-Host "Procurando em toda a pasta build..."
            Get-ChildItem -Path "build" -Filter "*.exe" -Recurse | ForEach-Object {
              Write-Host "  Encontrado: $($_.FullName)"
            }
            throw "Execut√°vel n√£o encontrado"
          }
          
          Write-Host "‚úî Execut√°vel encontrado: $exeFound"
          
          $exeDir = Split-Path -Parent $exeFound
          "exe_path=$exeFound" >> $env:GITHUB_OUTPUT
          "exe_dir=$exeDir" >> $env:GITHUB_OUTPUT

      - name: Copiar DLLs do Qwt
        shell: pwsh
        run: |
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          Write-Host "Copiando DLLs do Qwt para: $exeDir"
          
          $qwtDlls = Get-ChildItem -Path "qwt/lib" -Filter "*.dll"
          foreach ($dll in $qwtDlls) {
            Copy-Item -Path $dll.FullName -Destination $exeDir -Force
            Write-Host "  Copiado: $($dll.Name)"
          }
          Write-Host "‚úî DLLs do Qwt copiadas"

      - name: windeployqt (incluir DLLs do Qt)
        shell: pwsh
        run: |
          $exePath = "${{ steps.find-exe.outputs.exe_path }}"
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          $qtRoot = if ($env:Qt5_Dir) { $env:Qt5_Dir } elseif ($env:Qt5_DIR) { $env:Qt5_DIR } else { "" }
          if (-not $qtRoot) {
            throw "Qt5_Dir/Qt5_DIR n√£o definido"
          }
          $qtBin = Join-Path $qtRoot "bin"
          $windeploy = Join-Path $qtBin "windeployqt.exe"
          $pluginPath = Join-Path $qtRoot "plugins"
          $env:QT_PLUGIN_PATH = $pluginPath
          $env:PATH = "$qtBin;$env:PATH"
          
          Write-Host "Executando windeployqt em: $exePath"
          Write-Host "Usando: $windeploy"
          
          & $windeploy --release --no-translations --no-system-d3d-compiler --no-opengl-sw --dir "$exeDir" "$exePath"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ö†Ô∏è windeployqt retornou c√≥digo: $LASTEXITCODE (continuando...)"
            $platformDir = Join-Path $exeDir "platforms"
            $qwindowsDll = Join-Path $platformDir "qwindows.dll"
            if (-not (Test-Path $qwindowsDll)) {
              Write-Host "Plugin de plataforma n√£o encontrado. Copiando manualmente..."
              New-Item -ItemType Directory -Path $platformDir -Force | Out-Null
              Copy-Item -Path (Join-Path $pluginPath "platforms\qwindows.dll") -Destination $platformDir -Force
            }
          } else {
            Write-Host "‚úî windeployqt conclu√≠do"
          }
          
          Write-Host "`nConte√∫do do diret√≥rio do execut√°vel:"
          Get-ChildItem -Path $exeDir | Select-Object Name, Length

      - name: Criar pacote ZIP
        shell: pwsh
        run: |
          $exeDir = "${{ steps.find-exe.outputs.exe_dir }}"
          $releaseDir = "release"
          $zipPath = Join-Path $releaseDir $env:ZIP_NAME
          
          if (-not (Test-Path $releaseDir)) {
            New-Item -ItemType Directory -Path $releaseDir | Out-Null
          }
          
          if (Test-Path $zipPath) {
            Remove-Item $zipPath -Force
          }
          
          Write-Host "Criando ZIP: $zipPath"
          Compress-Archive -Path "$exeDir\*" -DestinationPath $zipPath
          
          if (-not (Test-Path $zipPath)) {
            throw "Falha ao criar ZIP"
          }
          
          $zipSize = (Get-Item $zipPath).Length / 1MB
          Write-Host "‚úî ZIP criado com sucesso: $([math]::Round($zipSize, 2)) MB"
          
          "zip_path=$zipPath" >> $env:GITHUB_OUTPUT

      - name: Upload artefato
        uses: actions/upload-artifact@v4
        with:
          name: IDS_DEStruct-${{ env.VERSION }}-windows-x64
          path: release/${{ env.ZIP_NAME }}
          if-no-files-found: error

      - name: Criar Release no GitHub
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION }}
          name: IDS_DEStruct ${{ env.VERSION }} (Windows x64)
          body: |
            ${{ github.event.inputs.notes }}
            
            ## üì¶ Download
            - **Windows x64 (MinGW)**: `${{ env.ZIP_NAME }}`
            
            ## üîß Requisitos
            - Windows 10/11 64-bit
            - Todas as DLLs necess√°rias est√£o inclu√≠das no pacote
            
            ## üìù Changelog
            Veja as mudan√ßas nesta vers√£o nos commits abaixo.
          prerelease: ${{ github.event.inputs.prerelease }}
          files: release/${{ env.ZIP_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
