name: Build & Release (Windows MinGW, portable) - IDS_DEStruct

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Versão/Tag (ex.: V1.0.0)"
        required: true
        type: string
      prerelease:
        description: "Marcar como pré-release?"
        required: false
        default: false
        type: boolean
      notes:
        description: "Notas da release (opcional)"
        required: false
        type: string

permissions:
  contents: write

env:
  VERSION: ${{ github.event.inputs.version }}
  ZIP_NAME: IDS_DEStruct-${{ github.event.inputs.version }}-windows-mingw64.zip
  ZIP_REL_PATH: release/IDS_DEStruct-${{ github.event.inputs.version }}-windows-mingw64.zip

jobs:
  build-windows-mingw:
    name: Windows (MSYS2/MinGW64 + Qt5 + Qwt) – Portable
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Habilitar long paths no Git
        shell: pwsh
        run: |
          git config --system core.longpaths true
          git config --global core.longpaths true

      - name: Setup MSYS2 + MinGW64 + Qt5 (+ Tools + Qwt)
        uses: msys2/setup-msys2@v2
        with:
          release: true
          update: true
          msystem: MINGW64
          path-type: minimal
          cache: true
          install: >-
            base-devel
            git
            zip
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-make
            mingw-w64-x86_64-binutils
            mingw-w64-x86_64-qt5-base
            mingw-w64-x86_64-qt5-svg
            mingw-w64-x86_64-qt5-opengl
            mingw-w64-x86_64-qt5-script
            mingw-w64-x86_64-qt5-tools
            mingw-w64-x86_64-qt5-translations
            mingw-w64-x86_64-ntldd-git
            mingw-w64-x86_64-qwt-qt5

      - name: Validar versão
        shell: bash
        run: |
          set -euo pipefail
          test -n "${VERSION}" || { echo "Versão não informada."; exit 1; }
          echo "Versão/Tag alvo: ${VERSION}"

      - name: Detectar Qt (qmake-qt5, windeployqt-qt5) + plugins
        shell: msys2 {0}
        run: |
          set -Eeuo pipefail
          export PATH="/mingw64/bin:$PATH"

          if [ -f "/mingw64/bin/qmake-qt5.exe" ]; then
            QMAKE="/mingw64/bin/qmake-qt5.exe"
          elif command -v qmake-qt5 >/dev/null 2>&1; then
            QMAKE="$(command -v qmake-qt5)"
          else
            echo "❌ qmake-qt5 não encontrado"; exit 1
          fi

          if [ -f "/mingw64/bin/windeployqt-qt5.exe" ]; then
            WINDEPLOY="/mingw64/bin/windeployqt-qt5.exe"
          elif command -v windeployqt-qt5 >/dev/null 2>&1; then
            WINDEPLOY="$(command -v windeployqt-qt5)"
          else
            WINDEPLOY=""
          fi

          PLUG_DIR="$("$QMAKE" -query QT_INSTALL_PLUGINS || true)"
          if [ -z "$PLUG_DIR" ] || [ ! -d "$PLUG_DIR" ]; then
            for d in /mingw64/share/qt5/plugins /mingw64/plugins /mingw64/lib/qt5/plugins; do
              [ -d "$d" ] && PLUG_DIR="$d" && break
            done
          fi

          echo "QMAKE=$QMAKE" >> $GITHUB_ENV
          echo "WINDEPLOY=$WINDEPLOY" >> $GITHUB_ENV
          echo "QT_PLUGIN_PATH=$PLUG_DIR" >> $GITHUB_ENV
          echo "/mingw64/bin" >> $GITHUB_PATH

          echo "✔ QMAKE=$QMAKE"
          echo "✔ WINDEPLOY=$WINDEPLOY"
          echo "✔ QT_PLUGIN_PATH=$PLUG_DIR"

      - name: Criar alias "lrelease" (se necessário)
        shell: msys2 {0}
        run: |
          set -Eeuo pipefail
          export PATH="/mingw64/bin:$PATH"
          if [ ! -f /mingw64/bin/lrelease.exe ] && [ -f /mingw64/bin/lrelease-qt5.exe ]; then
            cp -f /mingw64/bin/lrelease-qt5.exe /mingw64/bin/lrelease.exe
          fi
          command -v lrelease >/dev/null 2>&1 || true

      - name: Preflight do projeto
        shell: bash
        run: |
          set -euo pipefail
          [ -f IDS_DEStruct.pro ] || { echo "❌ IDS_DEStruct.pro não encontrado na raiz do repo."; ls -la; exit 1; }

      - name: Gerar ci_qwt.pri (detecta include/lib do Qwt instalado)
        shell: msys2 {0}
        run: |
          set -Eeuo pipefail
          export PATH="/mingw64/bin:$PATH"

          PKG="mingw-w64-x86_64-qwt-qt5"
          pacman -Q "$PKG" >/dev/null 2>&1 || { echo "❌ Pacote $PKG não instalado."; exit 1; }

          # Descobre um include dir contendo qwt_plot.h
          INC_CAND="$(pacman -Ql "$PKG" | awk '{print $2}' | tr '\r' '\n' | grep -E '/include/.*/qwt_plot\.h$' | head -n 1 || true)"
          if [ -z "$INC_CAND" ]; then
            # fallback: procura por qualquer qwt_plot.h
            INC_CAND="$(find /mingw64/include -maxdepth 3 -name qwt_plot.h 2>/dev/null | head -n 1 || true)"
          fi
          [ -n "$INC_CAND" ] || { echo "❌ Não achei qwt_plot.h"; exit 1; }
          INC_DIR="$(dirname "$INC_CAND")"

          # Descobre lib (static ou import lib)
          LIB_CAND="$(pacman -Ql "$PKG" | awk '{print $2}' | tr '\r' '\n' | grep -E '/lib/(libqwt.*\.(a|dll\.a))$' | head -n 1 || true)"
          if [ -z "$LIB_CAND" ]; then
            LIB_CAND="$(find /mingw64/lib -maxdepth 1 -name 'libqwt*.a' -o -name 'libqwt*.dll.a' 2>/dev/null | head -n 1 || true)"
          fi
          [ -n "$LIB_CAND" ] || { echo "❌ Não achei libqwt*.a/.dll.a"; exit 1; }
          LIB_DIR="$(dirname "$LIB_CAND")"
          LIB_FILE="$(basename "$LIB_CAND")"

          # Extrai -lXXXX (remove lib e extensão)
          LIB_NAME="$LIB_FILE"
          LIB_NAME="${LIB_NAME#lib}"
          LIB_NAME="${LIB_NAME%.dll.a}"
          LIB_NAME="${LIB_NAME%.a}"

          cat > ci_qwt.pri <<EOF
# ===== CI QWT (auto) =====
INCLUDEPATH += $INC_DIR
DEPENDPATH  += $INC_DIR
DEFINES     += QT_DLL QWT_DLL
LIBS        += -L$LIB_DIR -l$LIB_NAME
# =========================
EOF

          echo "✔ ci_qwt.pri criado:"
          cat ci_qwt.pri

      - name: Patch no IDS_DEStruct.pro (remove DESTDIR hardcoded + desativa LIBS antigo do Qwt + inclui ci_qwt.pri)
        shell: msys2 {0}
        run: |
          set -Eeuo pipefail
          export PATH="/mingw64/bin:$PATH"

          # 1) Comenta DESTDIR hardcoded (D:\Exec\Release etc)
          # 2) Comenta LIBS que referencia $${QWT_LOCATION}\lib\libqwt*.a (inexistente no CI)
          # 3) Garante include(ci_qwt.pri) no final
          # 4) Define DESTDIR para pasta local (portable)
          sed -i 's/^[[:space:]]*DESTDIR[[:space:]]*=.*/# &/g' IDS_DEStruct.pro

          sed -i 's|^[[:space:]]*LIBS[[:space:]]*+=.*QWT_LOCATION.*lib.*lib\$\${QWTLIB}.*|# &\n# (CI) Qwt é linkado via ci_qwt.pri|g' IDS_DEStruct.pro

          # evita duplicar include
          if ! grep -q 'include(ci_qwt.pri)' IDS_DEStruct.pro; then
            printf "\n# ===== CI OVERRIDES =====\nDESTDIR = \$$OUT_PWD/bin\ninclude(ci_qwt.pri)\n# =======================\n" >> IDS_DEStruct.pro
          fi

          echo "---- IDS_DEStruct.pro (trecho final) ----"
          tail -n 40 IDS_DEStruct.pro

      - name: Compilar (qmake + mingw32-make Release) - build out-of-source
        shell: msys2 {0}
        run: |
          set -Eeuo pipefail
          export PATH="/mingw64/bin:$PATH"

          rm -rf build_ci
          mkdir -p build_ci
          cd build_ci

          rm -f Makefile* .qmake.stash 2>/dev/null || true
          "$QMAKE" ../IDS_DEStruct.pro "CONFIG+=release"

          CORES=$(nproc || echo 2)
          mingw32-make -j"${CORES}" release

      - name: Localizar executável (.exe)
        id: exe
        shell: bash
        run: |
          set -euo pipefail
          shopt -s globstar nullglob nocaseglob

          mapfile -t CAND < <(ls -1t build_ci/**/IDS_DEStruct*.exe build_ci/**/ids_destruct*.exe 2>/dev/null || true)
          if [ ${#CAND[@]} -eq 0 ]; then
            echo "❌ Nenhum .exe encontrado em build_ci"
            find build_ci -maxdepth 6 -type f -name "*.exe" -print 2>/dev/null || true
            exit 1
          fi

          EXE="${CAND[0]}"
          EXE_DIR="$(dirname "$EXE")"

          echo "Executável: $EXE"
          echo "exe_unix=$EXE" >> $GITHUB_OUTPUT
          echo "exe_dir_unix=$EXE_DIR" >> $GITHUB_OUTPUT
          echo "exe_win=$(cygpath -w "$EXE")" >> $GITHUB_OUTPUT
          echo "exe_dir_win=$(cygpath -w "$EXE_DIR")" >> $GITHUB_OUTPUT

      - name: windeployqt (portable) – se disponível
        shell: msys2 {0}
        env:
          QT_PLUGIN_PATH: ${{ env.QT_PLUGIN_PATH }}
        run: |
          set -Eeuo pipefail
          export PATH="/mingw64/bin:$PATH"

          EXE_WIN="${{ steps.exe.outputs.exe_win }}"
          if [ -z "${WINDEPLOY}" ]; then
            echo "⚠️ windeployqt não encontrado — pulando."
            exit 0
          fi

          "$WINDEPLOY" --compiler-runtime "$EXE_WIN" || true

      - name: Empacotar ZIP (portable) em release/
        shell: pwsh
        run: |
          $exeDirWin  = "${{ steps.exe.outputs.exe_dir_win }}"
          $workspace  = "${{ github.workspace }}"
          $releaseDir = Join-Path $workspace "release"

          if (-not (Test-Path $releaseDir)) { New-Item -ItemType Directory -Path $releaseDir | Out-Null }

          $zipPathAbs = Join-Path $releaseDir "${{ env.ZIP_NAME }}"
          if (Test-Path $zipPathAbs) { Remove-Item $zipPathAbs -Force }

          Compress-Archive -Path (Join-Path $exeDirWin '*') -DestinationPath $zipPathAbs

          if (-not (Test-Path $zipPathAbs)) { throw "ZIP não foi gerado em: $zipPathAbs" }
          Write-Host "ZIP gerado: $zipPathAbs"

      - name: Publicar artefato (CI)
        uses: actions/upload-artifact@v4
        with:
          name: IDS_DEStruct-${{ env.VERSION }}-windows-mingw64
          path: ${{ env.ZIP_REL_PATH }}
          if-no-files-found: error

      - name: Criar Release + Tag (anexando o ZIP)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION }}
          name: IDS_DEStruct ${{ env.VERSION }} (Windows MinGW, portable)
          body: ${{ github.event.inputs.notes }}
          prerelease: ${{ github.event.inputs.prerelease }}
          files: ${{ env.ZIP_REL_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}